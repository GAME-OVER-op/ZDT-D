<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Мониторинг ресурсов - Zapret</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Светлая тема */
            --primary: #5e35b1;
            --primary-light: #7e57c2;
            --primary-dark: #4527a0;
            --secondary: #26a69a;
            --success: #43a047;
            --error: #e53935;
            --warning: #ff9800;
            --surface: #ffffff;
            --background: #f5f7fa;
            --text-primary: #333333;
            --text-secondary: #666666;
            --border: #e0e0e0;
            --shadow: rgba(94, 53, 177, 0.1);
            --nav-bg: #ffffff;
            --card-bg: #ffffff;
            --log-header-bg: rgba(94, 53, 177, 0.05);
            --stat-bg: rgba(94, 53, 177, 0.05);
            --chart-line-color: #1e3f7e; /* Темно-синий для светлой темы */
        }

        [data-theme="dark"] {
            /* Темная тема */
            --primary: #7e57c2;
            --primary-light: #9575cd;
            --primary-dark: #654ea3;
            --secondary: #26a69a;
            --success: #66bb6a;
            --error: #ef5350;
            --warning: #ffa726;
            --surface: #1e1e1e;
            --background: #121212;
            --text-primary: #e0e0e0;
            --text-secondary: #9e9e9e;
            --border: #333333;
            --shadow: rgba(0, 0, 0, 0.2);
            --nav-bg: #1e1e1e;
            --card-bg: #1e1e1e;
            --log-header-bg: rgba(126, 87, 194, 0.15);
            --stat-bg: rgba(126, 87, 194, 0.1);
            --chart-line-color: #4d8fea; /* Светло-синий для темной темы */
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }
        
        body {
            background: var(--background);
            min-height: 100vh;
            font-family: 'Roboto', sans-serif;
            color: var(--text-primary);
            line-height: 1.6;
            display: flex;
            flex-direction: column;
        }
        
        .container {
            max-width: 1200px;
            width: 100%;
            margin: 0 auto;
            padding: 20px;
            flex: 1;
        }
        
        header {
            text-align: center;
            padding: 20px 20px 10px;
            position: relative;
        }
        
        .logo {
            width: 70px;
            height: 70px;
            background: var(--primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 15px;
            box-shadow: 0 4px 12px rgba(94, 53, 177, 0.25);
        }
        
        .logo i {
            font-size: 34px;
            color: white;
            position: relative;
            top: 1px;
        }
        
        h1 {
            font-size: 1.6rem;
            color: var(--primary-light);
            font-weight: 700;
            margin-bottom: 5px;
        }
        
        .subtitle {
            color: var(--text-secondary);
            font-size: 1rem;
            font-weight: 400;
        }
        
        nav {
            display: flex;
            justify-content: center;
            margin: 20px 0;
            background: var(--nav-bg);
            border-radius: 15px;
            box-shadow: 0 4px 12px var(--shadow);
            overflow: hidden;
            flex-wrap: nowrap;
            overflow-x: auto;
            border: 1px solid var(--border);
        }
        
        .nav-item {
            flex: 1 0 auto;
            min-width: 100px;
            text-align: center;
            padding: 12px 8px;
            text-decoration: none;
            color: var(--text-secondary);
            font-weight: 500;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.3s ease;
            white-space: nowrap;
        }
        
        .nav-item i {
            margin-bottom: 4px;
            font-size: 18px;
            transition: color 0.3s ease;
        }
        
        .nav-item.active, .nav-item:hover {
            background: var(--primary);
            color: white;
        }
        
        .nav-item.active i, .nav-item:hover i {
            color: white;
        }
        
        /* Новые стили для сетевой статистики */
        .network-section {
            background: var(--card-bg);
            border-radius: 15px;
            box-shadow: 0 5px 20px var(--shadow);
            padding: 20px;
            margin-bottom: 30px;
            transition: all 0.3s ease;
        }
        
        .network-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 10px;
        }
        
        .network-icon {
            width: 40px;
            height: 40px;
            background: rgba(94, 53, 177, 0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
        }
        
        .network-icon i {
            color: var(--primary);
            font-size: 20px;
        }
        
        .network-title {
            font-weight: 600;
            font-size: 1.1rem;
            flex-grow: 1;
        }
        
        .network-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .stat-group {
            background: var(--stat-bg);
            border-radius: 10px;
            padding: 15px;
            text-align: left;
        }
        
        .stat-group-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--primary-light);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px dashed var(--border);
        }
        
        .stat-row:last-child {
            border-bottom: none;
        }
        
        .stat-label {
            color: var(--text-secondary);
        }
        
        .stat-value {
            font-weight: 600;
        }
        
        .traffic-chart-container {
            margin-top: 20px;
            background: var(--stat-bg);
            border-radius: 10px;
            padding: 15px;
        }
        
        .traffic-chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .chart-title {
            font-weight: 600;
            color: var(--primary-light);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .chart-container {
            height: 200px;
            position: relative;
        }
        
        canvas {
            width: 100%;
            height: 100%;
        }
        
        .interface-selector {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        
        .interface-btn {
            background: rgba(94, 53, 177, 0.1);
            border: none;
            border-radius: 20px;
            padding: 6px 12px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .interface-btn.active {
            background: var(--primary);
            color: white;
        }
        
        .monitoring-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .service-card {
            background: var(--card-bg);
            border-radius: 15px;
            box-shadow: 0 5px 20px var(--shadow);
            padding: 20px;
            transition: all 0.3s ease;
            border-left: 4px solid var(--primary);
            display: flex;
            flex-direction: column;
        }
        
        .service-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px var(--shadow);
        }
        
        .service-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 10px;
        }
        
        .service-icon {
            width: 40px;
            height: 40px;
            background: rgba(94, 53, 177, 0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
        }
        
        .service-icon i {
            color: var(--primary);
            font-size: 20px;
        }
        
        .service-name {
            font-weight: 600;
            font-size: 1.1rem;
            flex-grow: 1;
        }
        
        .service-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            flex-grow: 1;
        }
        
        .stat-item {
            background: var(--stat-bg);
            border-radius: 10px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        .stat-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-weight: 600;
            font-size: 1.2rem;
            color: var(--primary-light);
            transition: all 0.3s ease;
        }
        
        .log-section {
            background: var(--card-bg);
            border-radius: 15px;
            box-shadow: 0 5px 20px var(--shadow);
            overflow: hidden;
            margin-top: 10px;
        }
        
        .log-header {
            background: var(--log-header-bg);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .log-header h3 {
            font-size: 1.2rem;
            color: var(--primary-light);
            font-weight: 600;
            display: flex;
            align-items: center;
            margin: 0;
        }
        
        .log-header h3 i {
            margin-right: 10px;
            color: var(--primary);
        }
        
        .log-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .log-control-btn {
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 8px 15px;
            font-size: 0.9rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .log-control-btn:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
        }
        
        .log-content {
            padding: 15px;
            height: 400px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.9rem;
            background: #1e1e1e;
            color: #d4d4d4;
            white-space: pre-wrap;
            line-height: 1.5;
        }
        
        .update-info {
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-top: 10px;
        }
        
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
        }
        
        .loading i {
            font-size: 40px;
            color: var(--primary);
            animation: spin 1.5s linear infinite;
        }
        
        .status-indicator {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.9rem;
            margin-left: 5px;
        }
        
        .status-running {
            background-color: rgba(67, 160, 71, 0.2);
            color: var(--success);
        }
        
        .status-stopped {
            background-color: rgba(255, 152, 0, 0.2);
            color: var(--warning);
        }
        
        .status-error {
            background-color: rgba(229, 57, 53, 0.2);
            color: var(--error);
        }
        
        .highlight {
            animation: highlight 0.8s ease;
        }
        
        .refresh-stats-btn {
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 10px 20px;
            font-size: 1rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
            margin-left: auto;
            margin-right: 0;
        }
        
        .refresh-stats-btn:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
        }
        
        .controls-container {
            display: flex;
            justify-content: flex-end;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes highlight {
            0% { background-color: rgba(94, 53, 177, 0.3); }
            100% { background-color: transparent; }
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .monitoring-section {
                grid-template-columns: 1fr;
            }
            
            .log-content {
                height: 300px;
            }
            
            .log-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .log-controls {
                width: 100%;
                justify-content: flex-end;
            }
            
            .network-stats {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 480px) {
            .nav-item span {
                font-size: 0.8rem;
            }
            
            .service-stats {
                grid-template-columns: 1fr;
            }
            
            .log-controls {
                flex-direction: row;
                width: 100%;
            }
            
            .log-control-btn {
                flex: 1;
                justify-content: center;
            }
            
            .refresh-stats-btn {
                width: 100%;
                justify-content: center;
            }
            
            .interface-selector {
                justify-content: center;
            }
        }
    </style>
    <script type="module">
        import { exec } from '/kernelsu.js';
        
        const LOG_PATH = '/data/adb/modules/ZDT-D/log/service.log';
        const UPDATE_INTERVAL = 5000; // 5 секунд
        
        const SERVICES = [
            { 
                name: "Zapret (nfqws)", 
                command: "nfqws", 
                icon: "security",
                id: "zapret"
            },
            { 
                name: "DPI Tunnel (dpitunnel-cli)", 
                command: "dpitunnel-cli", 
                icon: "tune",
                id: "dpi-tunnel"
            },
            { 
                name: "DNSCrypt (dnscrypt-proxy.toml)", 
                command: "dnscrypt-proxy.toml", 
                icon: "dns",
                id: "dnscrypt"
            },
            { 
                name: "ByeDPI (ciadpi-zdt)", 
                command: "ciadpi-zdt", 
                icon: "vpn_key",
                id: "bye-dpi"
            }
        ];
        
        // Флаг для отслеживания первого запуска
        let firstRun = true;
        let updateTimer = null;
        
        // Данные для графиков трафика
        let trafficHistory = {};
        let prevTraffic = {};
        const MAX_HISTORY = 30;
        let selectedInterface = 'all';

        // Инициализация темы
        function initTheme() {
            const savedTheme = localStorage.getItem('theme');
            const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            
            if (savedTheme) {
                document.documentElement.setAttribute('data-theme', savedTheme);
            } else if (systemPrefersDark) {
                document.documentElement.setAttribute('data-theme', 'dark');
            }
        }
        
        async function getServiceStats(service) {
            try {
                const { stdout: pidStdout } = await exec(`pgrep -f ${service.command}`);
                const pids = pidStdout.trim().split('\n').filter(pid => pid.trim() !== '');
                
                if (pids.length === 0) {
                    return {
                        id: service.id,
                        status: "Остановлен",
                        cpu: "0%",
                        minCpu: "0%",
                        maxCpu: "0%",
                        mem: "0 MB",
                        pids: []
                    };
                }
                
                // Получаем детальную статистику по процессам
                const { stdout: psStdout } = await exec(`ps -o %cpu,rss -p ${pids.join(',')}`);
                const lines = psStdout.trim().split('\n').slice(1);
                
                let totalMem = 0;
                let cpuValues = [];
                
                for (const line of lines) {
                    if (line.trim() === '') continue;
                    const [cpu, mem] = line.trim().split(/\s+/);
                    const cpuVal = parseFloat(cpu);
                    cpuValues.push(cpuVal);
                    totalMem += parseInt(mem);
                }
                
                // Рассчитываем min/max CPU
                let minCpu = 0;
                let maxCpu = 0;
                if (cpuValues.length > 0) {
                    minCpu = Math.min(...cpuValues);
                    maxCpu = Math.max(...cpuValues);
                }
                
                // Переводим память в MB
                totalMem = (totalMem / 1024).toFixed(1);
                
                return {
                    id: service.id,
                    status: "Запущен",
                    cpu: `${cpuValues.reduce((a, b) => a + b, 0).toFixed(1)}%`,
                    minCpu: `${minCpu.toFixed(1)}%`,
                    maxCpu: `${maxCpu.toFixed(1)}%`,
                    mem: `${totalMem} MB`,
                    pids: pids
                };
                
            } catch (error) {
                console.error(`Ошибка для ${service.name}:`, error);
                return {
                    id: service.id,
                    status: "Ошибка",
                    cpu: "N/A",
                    minCpu: "N/A",
                    maxCpu: "N/A",
                    mem: "N/A",
                    pids: []
                };
            }
        }
        
        async function updateServiceStats() {
            try {
                const stats = [];
                for (const service of SERVICES) {
                    stats.push(await getServiceStats(service));
                }
                
                stats.forEach(stat => {
                    const card = document.getElementById(`${stat.id}-card`);
                    if (!card) return;
                    
                    card.querySelector(`#${stat.id}-status`).textContent = stat.status;
                    card.querySelector(`#${stat.id}-cpu`).textContent = stat.cpu;
                    card.querySelector(`#${stat.id}-min-cpu`).textContent = stat.minCpu;
                    card.querySelector(`#${stat.id}-max-cpu`).textContent = stat.maxCpu;
                    card.querySelector(`#${stat.id}-mem`).textContent = stat.mem;
                    card.querySelector(`#${stat.id}-pids`).textContent = 
                        stat.pids.length > 0 ? stat.pids.join(', ') : '-';
                    
                    // Обновляем классы статуса
                    const statusEl = card.querySelector(`#${stat.id}-status`);
                    statusEl.className = 'status-indicator';
                    if (stat.status === 'Запущен') statusEl.classList.add('status-running');
                    else if (stat.status === 'Остановлен') statusEl.classList.add('status-stopped');
                    else statusEl.classList.add('status-error');
                });
                
                const now = new Date();
                document.getElementById('last-update').textContent = 
                    `Последнее обновление: ${now.toLocaleTimeString()}`;
                
            } catch (error) {
                console.error('Ошибка обновления статистики:', error);
            } finally {
                firstRun = false;
            }
        }
        
        async function updateLogs() {
            try {
                const { stdout } = await exec(`tail -n 100 ${LOG_PATH}`);
                const logContent = document.getElementById('log-content');
                
                if (logContent.textContent !== stdout) {
                    logContent.textContent = stdout;
                    logContent.scrollTop = logContent.scrollHeight;
                }
                
            } catch (error) {
                console.error('Ошибка чтения логов:', error);
            }
        }
        
        async function clearLogs() {
            if (!confirm('Вы уверены, что хотите очистить логи?')) return;
            
            try {
                await exec(`echo "" > ${LOG_PATH}`);
                updateLogs();
            } catch (error) {
                console.error('Ошибка очистки логов:', error);
                alert('Не удалось очистить логи');
            }
        }
        
        function createServiceCards() {
            let html = '';
            SERVICES.forEach(service => {
                html += `
                    <div class="service-card" id="${service.id}-card">
                        <div class="service-header">
                            <div class="service-icon">
                                <i class="material-icons">${service.icon}</i>
                            </div>
                            <div class="service-name">${service.name}</div>
                        </div>
                        <div class="service-stats">
                            <div class="stat-item">
                                <div class="stat-label">Статус</div>
                                <div class="stat-value">
                                    <span id="${service.id}-status" class="status-indicator status-stopped">Загрузка...</span>
                                </div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Исп. CPU (общ)</div>
                                <div class="stat-value">
                                    <span id="${service.id}-cpu">0%</span>
                                </div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Min CPU (проц.)</div>
                                <div class="stat-value">
                                    <span id="${service.id}-min-cpu">0%</span>
                                </div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Max CPU (проц.)</div>
                                <div class="stat-value">
                                    <span id="${service.id}-max-cpu">0%</span>
                                </div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Память</div>
                                <div class="stat-value">
                                    <span id="${service.id}-mem">0 MB</span>
                                </div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">PID</div>
                                <div class="stat-value">
                                    <span id="${service.id}-pids">-</span>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });
            document.getElementById('monitoring-section').innerHTML = html;
        }
        
        // ===== ИСПРАВЛЕНИЯ ДЛЯ СЕТЕВОЙ СТАТИСТИКИ =====
        
        // Исправленный подсчет активных соединений
        async function getNetworkConnections() {
            try {
                // Получаем все соединения одной командой
                const { stdout } = await exec('ss -tun 2>/dev/null');
                const lines = stdout.trim().split('\n').slice(1); // Пропускаем заголовок
                
                // Счетчики
                let total = 0;
                let tcp = 0;
                let udp = 0;
                let ipv4 = 0;
                let ipv6 = 0;
                
                lines.forEach(line => {
                    if (line.trim() === '') return;
                    
                    const parts = line.trim().split(/\s+/);
                    if (parts.length < 5) return;
                    
                    const type = parts[0];
                    const local = parts[4];
                    
                    total++;
                    
                    if (type === 'tcp') tcp++;
                    else if (type === 'udp') udp++;
                    
                    if (local.includes('.')) ipv4++;
                    else if (local.includes(':')) ipv6++;
                });
                
                return {
                    total,
                    tcp,
                    udp,
                    ipv4,
                    ipv6
                };
            } catch (error) {
                console.error('Ошибка получения сетевых соединений:', error);
                return {
                    total: 0,
                    tcp: 0,
                    udp: 0,
                    ipv4: 0,
                    ipv6: 0
                };
            }
        }
        
        // Получение прослушиваемых портов
        async function getListeningPorts() {
            try {
                const commands = {
                    tcp: 'ss -tln 2>/dev/null | tail -n +2 | wc -l',
                    udp: 'ss -uln 2>/dev/null | tail -n +2 | wc -l'
                };
                
                const results = {};
                for (const [key, cmd] of Object.entries(commands)) {
                    const { stdout } = await exec(cmd);
                    results[key] = parseInt(stdout.trim()) || 0;
                }
                
                results.total = results.tcp + results.udp;
                return results;
            } catch (error) {
                console.error('Ошибка получения прослушиваемых портов:', error);
                return {
                    total: 0,
                    tcp: 0,
                    udp: 0
                };
            }
        }
        
        // Получение статистики интерфейсов (только с ненулевой скоростью)
        async function getInterfaceTraffic() {
            try {
                const { stdout } = await exec('cat /proc/net/dev');
                const lines = stdout.split('\n').slice(2); // Skip header lines
                const currentTraffic = {};
                const interfaces = [];
                
                lines.forEach(line => {
                    const parts = line.trim().split(/\s+/);
                    if (parts.length < 10) return;
                    
                    const iface = parts[0].replace(':', '');
                    // Skip loopback and virtual interfaces
                    if (iface.startsWith('lo') || iface.startsWith('sit') || 
                        iface.startsWith('tun') || iface.startsWith('dummy')) return;
                    
                    const rx = parseInt(parts[1]);
                    const tx = parseInt(parts[9]);
                    
                    currentTraffic[iface] = { rx, tx };
                    interfaces.push(iface);
                });
                
                // Calculate speeds
                const speeds = [];
                const now = Date.now();
                
                for (const iface of interfaces) {
                    const curr = currentTraffic[iface];
                    const prev = prevTraffic[iface];
                    
                    let rxSpeed = 0;
                    let txSpeed = 0;
                    
                    if (prev && prev.timestamp) {
                        const timeDiff = (now - prev.timestamp) / 1000; // in seconds
                        const rxDiff = curr.rx - prev.rx;
                        const txDiff = curr.tx - prev.tx;
                        
                        if (rxDiff >= 0) rxSpeed = rxDiff / timeDiff / 1024; // KB/s
                        if (txDiff >= 0) txSpeed = txDiff / timeDiff / 1024; // KB/s
                    }
                    
                    // Добавляем только интерфейсы с ненулевой скоростью
                    if (rxSpeed > 0 || txSpeed > 0) {
                        speeds.push({
                            iface,
                            rx: parseFloat(rxSpeed.toFixed(2)),
                            tx: parseFloat(txSpeed.toFixed(2))
                        });
                    }
                    
                    // Store current values for next time
                    prevTraffic[iface] = {
                        rx: curr.rx,
                        tx: curr.tx,
                        timestamp: now
                    };
                }
                
                return speeds;
            } catch (error) {
                console.error('Ошибка получения трафика интерфейсов:', error);
                return [];
            }
        }
        
        // Обновление истории трафика для графиков
        function updateTrafficHistory(interfaces) {
            // Initialize history if empty
            if (Object.keys(trafficHistory).length === 0) {
                interfaces.forEach(iface => {
                    trafficHistory[iface.iface] = {
                        rx: new Array(MAX_HISTORY).fill(0),
                        tx: new Array(MAX_HISTORY).fill(0)
                    };
                });
            }
            
            // Update history for each interface
            interfaces.forEach(iface => {
                if (!trafficHistory[iface.iface]) {
                    trafficHistory[iface.iface] = {
                        rx: new Array(MAX_HISTORY).fill(0),
                        tx: new Array(MAX_HISTORY).fill(0)
                    };
                }
                
                // Shift history and add new values
                trafficHistory[iface.iface].rx.shift();
                trafficHistory[iface.iface].rx.push(iface.rx);
                
                trafficHistory[iface.iface].tx.shift();
                trafficHistory[iface.iface].tx.push(iface.tx);
            });
        }
        
        // Отрисовка графиков с исправлениями
        function drawTrafficChart() {
            const canvas = document.getElementById('traffic-chart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // No data to draw
            if (Object.keys(trafficHistory).length === 0) return;
            
            // Get interfaces to show
            let interfacesToShow = [];
            if (selectedInterface === 'all') {
                interfacesToShow = Object.keys(trafficHistory);
            } else if (trafficHistory[selectedInterface]) {
                interfacesToShow = [selectedInterface];
            }
            
            if (interfacesToShow.length === 0) return;
            
            // Find max value for scaling (minimum 1)
            let maxValue = 1;
            interfacesToShow.forEach(iface => {
                const maxRx = Math.max(...trafficHistory[iface].rx);
                const maxTx = Math.max(...trafficHistory[iface].tx);
                maxValue = Math.max(maxValue, maxRx, maxTx);
            });
            
            // Draw grid
            ctx.strokeStyle = 'rgba(94, 53, 177, 0.1)';
            ctx.lineWidth = 1;
            
            // Horizontal lines
            for (let i = 0; i <= 5; i++) {
                const y = height - 20 - (i * (height - 40) / 5);
                ctx.beginPath();
                ctx.moveTo(30, y);
                ctx.lineTo(width - 10, y);
                ctx.stroke();
                
                // Label
                ctx.fillStyle = 'var(--text-secondary)';
                ctx.font = '10px Roboto';
                ctx.fillText((maxValue * i / 5).toFixed(1) + ' KB/s', 5, y + 4);
            }
            
            // Draw zero line
            ctx.strokeStyle = 'rgba(94, 53, 177, 0.3)';
            ctx.beginPath();
            ctx.moveTo(30, height - 20);
            ctx.lineTo(width - 10, height - 20);
            ctx.stroke();
            
            // Draw RX and TX for each interface
            const colors = [
                { rx: 'var(--chart-line-color)', tx: 'rgba(94, 53, 177, 0.5)' },
                { rx: 'rgba(33, 150, 243, 0.7)', tx: 'rgba(33, 150, 243, 0.3)' },
                { rx: 'rgba(255, 152, 0, 0.7)', tx: 'rgba(255, 152, 0, 0.3)' },
                { rx: 'rgba(156, 39, 176, 0.7)', tx: 'rgba(156, 39, 176, 0.3)' }
            ];
            
            interfacesToShow.forEach((iface, idx) => {
                const color = colors[idx % colors.length];
                
                // Draw RX (receive)
                ctx.beginPath();
                ctx.strokeStyle = color.rx;
                ctx.lineWidth = 2;
                ctx.setLineDash([0]); // Solid line
                
                trafficHistory[iface].rx.forEach((value, i) => {
                    const x = 30 + (i * (width - 40) / (MAX_HISTORY - 1));
                    const y = height - 20 - (value / maxValue) * (height - 40);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                    
                    // Draw marker points
                    if (value > 0) {
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, Math.PI * 2);
                        ctx.fillStyle = color.rx;
                        ctx.fill();
                    }
                });
                
                ctx.stroke();
                
                // Draw TX (transmit)
                ctx.beginPath();
                ctx.strokeStyle = color.tx;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 3]); // Dashed line
                
                trafficHistory[iface].tx.forEach((value, i) => {
                    const x = 30 + (i * (width - 40) / (MAX_HISTORY - 1));
                    const y = height - 20 - (value / maxValue) * (height - 40);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                    
                    // Draw marker points
                    if (value > 0) {
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, Math.PI * 2);
                        ctx.fillStyle = color.tx;
                        ctx.fill();
                    }
                });
                
                ctx.stroke();
                ctx.setLineDash([0]); // Reset to solid line
                
                // Draw legend only for 'all' view
                if (selectedInterface === 'all') {
                    const legendY = 20 + (idx * 20);
                    ctx.fillStyle = color.rx;
                    ctx.font = '10px Roboto';
                    ctx.textAlign = 'right';
                    ctx.fillText(`${iface} RX`, width - 10, legendY);
                    
                    ctx.fillStyle = color.tx;
                    ctx.fillText(`${iface} TX`, width - 10, legendY + 12);
                }
            });
            
            // Draw time markers
            ctx.fillStyle = 'var(--text-secondary)';
            ctx.font = '10px Roboto';
            ctx.textAlign = 'center';
            ctx.setLineDash([0]);
            
            ctx.fillText('-30s', 30, height - 5);
            ctx.fillText('now', width - 10, height - 5);
        }
        
        // Обновление UI сетевой статистики
        async function updateNetworkStats() {
            // Get all network data
            const connections = await getNetworkConnections();
            const ports = await getListeningPorts();
            const interfaces = await getInterfaceTraffic();
            
            // Update connections table
            if (connections) {
                document.getElementById('total-conn').textContent = connections.total;
                document.getElementById('tcp-conn').textContent = connections.tcp;
                document.getElementById('udp-conn').textContent = connections.udp;
                document.getElementById('ipv4-conn').textContent = connections.ipv4;
                document.getElementById('ipv6-conn').textContent = connections.ipv6;
            }
            
            // Update ports table
            if (ports) {
                document.getElementById('total-ports').textContent = ports.total;
                document.getElementById('tcp-ports').textContent = ports.tcp;
                document.getElementById('udp-ports').textContent = ports.udp;
            }
            
            // Update interfaces table
            const tableBody = document.getElementById('interfaces-body');
            tableBody.innerHTML = '';
            
            interfaces.forEach(iface => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${iface.iface}</td>
                    <td class="stat-value">${iface.rx.toFixed(2)}</td>
                    <td class="stat-value">${iface.tx.toFixed(2)}</td>
                `;
                tableBody.appendChild(row);
            });
            
            // Update traffic history and chart
            updateTrafficHistory(interfaces);
            drawTrafficChart();
            
            // Update interface selector
            updateInterfaceSelector(interfaces);
        }
        
        // Обновление селектора интерфейсов
        function updateInterfaceSelector(interfaces) {
            const container = document.getElementById('interface-selector');
            container.innerHTML = '';
            
            // Add "All" option
            const allBtn = document.createElement('button');
            allBtn.className = `interface-btn ${selectedInterface === 'all' ? 'active' : ''}`;
            allBtn.textContent = 'Все интерфейсы';
            allBtn.onclick = () => {
                selectedInterface = 'all';
                document.querySelectorAll('.interface-btn').forEach(btn => btn.classList.remove('active'));
                allBtn.classList.add('active');
                drawTrafficChart();
            };
            container.appendChild(allBtn);
            
            // Add interface options
            interfaces.forEach(iface => {
                const btn = document.createElement('button');
                btn.className = `interface-btn ${selectedInterface === iface.iface ? 'active' : ''}`;
                btn.textContent = iface.iface;
                btn.onclick = () => {
                    selectedInterface = iface.iface;
                    document.querySelectorAll('.interface-btn').forEach(btn => btn.classList.remove('active'));
                    btn.classList.add('active');
                    drawTrafficChart();
                };
                container.appendChild(btn);
            });
        }
        
        // Инициализация canvas
        function initCanvas() {
            const canvas = document.getElementById('traffic-chart');
            if (!canvas) return;
            
            // Set canvas dimensions
            const dpr = window.devicePixelRatio || 1;
            canvas.width = canvas.offsetWidth * dpr;
            canvas.height = canvas.offsetHeight * dpr;
            
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);
        }
        
        // Функция для обновления всех данных
        function updateAll() {
            updateNetworkStats();
            updateServiceStats();
            updateLogs();
        }
        
        // Инициализация
        document.addEventListener('DOMContentLoaded', () => {
            // Инициализация темы
            initTheme();
            
            // Инициализация canvas
            initCanvas();
            
            // Создание карточек сервисов
            createServiceCards();
            
            // Первоначальное обновление данных
            updateAll();
            
            // Обработчики кнопок
            document.getElementById('refresh-logs').addEventListener('click', updateLogs);
            document.getElementById('clear-logs').addEventListener('click', clearLogs);
            document.getElementById('refresh-stats').addEventListener('click', () => {
                updateNetworkStats();
                updateServiceStats();
            });
            
            // Обновление при фокусе
            window.addEventListener('focus', () => {
                if (!firstRun) {
                    updateAll();
                }
            });
            
            // Автоматическое обновление каждые 5 секунд
            updateTimer = setInterval(updateAll, UPDATE_INTERVAL);
            
            // Обработка ресайза окна
            window.addEventListener('resize', () => {
                initCanvas();
                drawTrafficChart();
            });
        });
        
        // Очистка интервала при закрытии страницы
        window.addEventListener('beforeunload', () => {
            if (updateTimer) {
                clearInterval(updateTimer);
            }
        });
    </script>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">
                <i class="material-icons">monitoring</i>
            </div>
            <h1>Мониторинг ресурсов</h1>
            <div class="subtitle">Статистика использования ресурсов и логи сервисов</div>
        </header>
        
        <nav>
            <a href="index.html" class="nav-item">
                <i class="material-icons">info</i>
                <span>Инфо</span>
            </a>
            <a href="domains.html" class="nav-item">
                <i class="material-icons">domain</i>
                <span>Домены</span>
            </a>
            <a href="config.html" class="nav-item">
                <i class="material-icons">build</i>
                <span>Конфиг</span>
            </a>
            <a href="#" class="nav-item active">
                <i class="material-icons">monitoring</i>
                <span>Мониторинг</span>
            </a>
            <a href="backup.html" class="nav-item">
                <i class="material-icons">backup</i>
                <span>Бэкап</span>
            </a>
        </nav>
        
        <!-- Секция сетевой статистики -->
        <div class="network-section">
            <div class="network-header">
                <div class="network-icon">
                    <i class="material-icons">network_check</i>
                </div>
                <div class="network-title">Сетевая статистика</div>
            </div>
            
            <div class="network-stats">
                <div class="stat-group">
                    <div class="stat-group-title">
                        <i class="material-icons">link</i>
                        Активные соединения
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Всего:</span>
                        <span id="total-conn" class="stat-value">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">TCP:</span>
                        <span id="tcp-conn" class="stat-value">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">UDP:</span>
                        <span id="udp-conn" class="stat-value">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">IPv4:</span>
                        <span id="ipv4-conn" class="stat-value">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">IPv6:</span>
                        <span id="ipv6-conn" class="stat-value">0</span>
                    </div>
                </div>
                
                <div class="stat-group">
                    <div class="stat-group-title">
                        <i class="material-icons">wifi_tethering</i>
                        Прослушиваемые порты
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Всего:</span>
                        <span id="total-ports" class="stat-value">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">TCP:</span>
                        <span id="tcp-ports" class="stat-value">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">UDP:</span>
                        <span id="udp-ports" class="stat-value">0</span>
                    </div>
                </div>
                
                <div class="stat-group">
                    <div class="stat-group-title">
                        <i class="material-icons">speed</i>
                        Скорость интерфейсов (КБ/с)
                    </div>
                    <table style="width: 100%;">
                        <thead>
                            <tr>
                                <th>Интерфейс</th>
                                <th>Прием</th>
                                <th>Отправка</th>
                            </tr>
                        </thead>
                        <tbody id="interfaces-body">
                            <tr>
                                <td colspan="3" style="text-align: center;">Загрузка...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            

        </div>
        
        <div class="controls-container">
            <button id="refresh-stats" class="refresh-stats-btn">
                <i class="material-icons">refresh</i>
                Обновить статистику
            </button>
        </div>
        
        <div class="monitoring-section" id="monitoring-section">
            <!-- Карточки создаются динамически -->
        </div>
        
        <div class="update-info" id="last-update">
            Загрузка данных...
        </div>
        
        <div class="log-section">
            <div class="log-header">
                <h3><i class="material-icons">list_alt</i> Логи сервиса</h3>
                <div class="log-controls">
                    <button id="refresh-logs" class="log-control-btn">
                        <i class="material-icons">refresh</i>
                        Обновить
                    </button>
                    <button id="clear-logs" class="log-control-btn">
                        <i class="material-icons">delete</i>
                        Очистить
                    </button>
                </div>
            </div>
            <div class="log-content" id="log-content">
                <!-- Логи загружаются динамически -->
            </div>
        </div>
    </div>
</body>
</html>